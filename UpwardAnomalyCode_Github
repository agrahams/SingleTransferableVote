#Cell 1
#Code written by Dave McCune and Adam Graham-Squire

import random
import pandas as pd
import math
import operator
import numpy as np
import copy


def truncate(number, digits) -> float: #truncates decimals per Scottish system
    stepper = 10.0 ** digits
    return math.trunc(stepper * number) / stepper

def STV3(frame3,n,S):
    frame2 = frame3.copy(deep=True)
    """Inputs election, n=number of candidates, S=number of seats.  Returns winners, losers=eliminated, 
      dictionary of pre-elimination data, dictionary of winners at each step of elimination"""
    winners=[]
    hopefuls=[]
    eliminatedCand=[]
    elimFrames={} #keeps track of election data at each round of elimination
    tempWinners={} #keeps track of who winners are at each round of elimination
    quota=math.floor(sum(frame2['Count'])/(S+1))+1
    
    #create list of all candidates
    list1=[]
    for k in range(len(frame2)):
        if frame2.at[k,'ballot']!='':
            if frame2.at[k,'ballot'][0] in list1:
                pass
            else:
                list1.append(frame2.at[k,'ballot'][0])
    cand_dict={}
    for i in range(n):
        cand_dict[i]=list1[i]
        hopefuls.append(list1[i])
        
    #Get each candidate's initial number of votes this round
    vote_counts={}
    
    for k in range(len(frame2)):
            if frame2.at[k,'ballot']!='':
                if frame2.at[k,'ballot'][0] in vote_counts.keys():
                    vote_counts[frame2.at[k,'ballot'][0]]+=frame2.iloc[k]['Count']
                else:
                    vote_counts[frame2.at[k,'ballot'][0]]=frame2.iloc[k]['Count']
    
    max_count=max(vote_counts.values())
    while len(winners)<S:
        
        max_count=max(vote_counts.values())
        #somebody is elected and we have to transfer their votes
        if max_count>=quota:
            #There might be multiple people elected this round; save them as a sorted dictionary
            votes_for_winners={k:vote_counts[k] for k in vote_counts.keys() if vote_counts[k]>=quota }
            votes_for_winners=dict(sorted(votes_for_winners.items(),key=lambda x: x[1], reverse=True))
            
            #If we try to elect too many people, need to drop someone who surpassed quota
            if len(winners)+len(votes_for_winners)>S:
                
                for k in range(len(winners)+len(votes_for_winners)-S):
                    winners.append(list(votes_for_winners.keys())[k])
            
            else:
                winners=winners+list(votes_for_winners.keys())
                for cand in winners:
                    if cand in hopefuls:
                        hopefuls.remove(cand)
                
                while len(votes_for_winners)>0:
                    
                    cand=list(votes_for_winners.keys())[0]
    
                    if cand not in winners:
                        winners.append(cand)
                        hopefuls.remove(cand)
                    if len(winners)==S: #if all winners are elected, end program
                        return winners, eliminatedCand, elimFrames, tempWinners
                    
                    weight=truncate((vote_counts[cand]-quota)/vote_counts[cand],5) #weight for transfer votes
                    
                    for k in range(len(frame2)):
                        if frame2.at[k,'ballot']!='':
                            if frame2.at[k,'ballot'][0]==cand: #find ballots with winner listed first
                                
                                frame2.at[k,'Count']=frame2.at[k,'Count']*weight #discount votes
                                for x in winners:
                                    if x in frame2.at[k,'ballot']:
                                        frame2.at[k,'ballot']=frame2.at[k,'ballot'].replace(x,'') #remove winners from ballot
                            else:
                                if cand in frame2.at[k,'ballot']:
                                     frame2.at[k,'ballot']=frame2.at[k,'ballot'].replace(cand,'') #remove winners from ballot
                    votes_for_winners.pop(cand)
                    vote_counts={}
                    
                    for k in range(len(frame2)): #calculate new vote counts
                        if frame2.at[k,'ballot']!='':
                            if frame2.at[k,'ballot'][0] in vote_counts.keys():
                                vote_counts[frame2.at[k,'ballot'][0]]+=frame2.iloc[k]['Count']
                            else:
                                vote_counts[frame2.at[k,'ballot'][0]]=frame2.iloc[k]['Count']

                    votes_for_winners={k:vote_counts[k] for k in vote_counts.keys() if vote_counts[k]>=quota }
                    votes_for_winners=dict(sorted(votes_for_winners.items(),key=lambda x: x[1], reverse=True))
                    for cand in votes_for_winners.keys():
                        if cand not in winners: #add to winners if above quota
                            winners.append(cand)
                            hopefuls.remove(cand)
                    if len(winners)==S:
                        return winners, eliminatedCand, elimFrames, tempWinners
                    frame2=pd.DataFrame(frame2.groupby(['ballot'],as_index=False)['Count'].sum())
        #nobody is elected by surpassing quota, but the number
        #of candidates left equals S
        elif len(hopefuls)+len(winners)==S:
            return winners+hopefuls, eliminatedCand, elimFrames, tempWinners
        
        #remove weakest cand and transfer their votes with weight one
        else:
            min_count=min(i for i in vote_counts.values() if i>0)
            count=0
            for votes in vote_counts:
                if votes==min_count:
                    count+=1
            if count>1:
                print("tie in candidate to remove")
                return

            eliminated_cand = list(vote_counts.keys())[list(vote_counts.values()).index(min_count)] #took str() away
            
            elimFrames[len(eliminatedCand)]=frame2.copy(deep=True) #save election data
            tempWinners[len(eliminatedCand)]=copy.deepcopy(winners) #save list of winners
            eliminatedCand.append(eliminated_cand)
            hopefuls.remove(eliminated_cand)
            
            for k in range(len(frame2)): #remove eliminated candidate from ballots
                if eliminated_cand in frame2.iloc[k]['ballot']:
                    frame2.at[k,'ballot']=frame2.at[k,'ballot'].replace(eliminated_cand,'')
            for k in range(len(frame2)):
                if frame2.at[k,'ballot']=='':
                    frame2.drop(k)
            vote_counts={}
           
            for k in range(len(frame2)): #recalculate election data
                if frame2.at[k,'ballot']!='':
                    if frame2.at[k,'ballot'][0] in vote_counts.keys():
                        vote_counts[frame2.at[k,'ballot'][0]]+=frame2.iloc[k]['Count']
                    else:
                        vote_counts[frame2.at[k,'ballot'][0]]=frame2.iloc[k]['Count']
                        
            max_count=max(vote_counts.values())
            if len(hopefuls)+len(winners)==S:
                return winners+hopefuls, eliminatedCand, elimFrames, tempWinners
            frame2=pd.DataFrame(frame2.groupby(['ballot'],as_index=False)['Count'].sum())
    return winners, eliminatedCand, elimFrames, tempWinners


#Cell 1.5
#Code written by Dave McCune and Adam Graham-Squire

import random
import pandas as pd
import math
import operator
import numpy as np


def truncate(number, digits) -> float:
    stepper = 10.0 ** digits
    return math.trunc(stepper * number) / stepper

def STV_temp(frame3,n,S,winners, temp_quota): #this is to be used to run a test election once 
    # some votes have been modified or removed (basically same as STV3)
    frame2 = frame3.copy(deep=True)
    """Inputs election, n=number of candidates, S=number of seats.  Returns winners"""
    
    hopefuls=[]
    eliminatedCand=[]
    quota = temp_quota
    
    list1=[]
    for k in range(len(frame2)):
        if frame2.at[k,'ballot']!='':
            if frame2.at[k,'ballot'][0] in list1:
                pass
            else:
                list1.append(frame2.at[k,'ballot'][0])
    cand_dict={}
    for i in range(n):
        cand_dict[i]=list1[i]
        hopefuls.append(list1[i])
        
    #Get each candidate's initial number of votes this round
    vote_counts={}
    
    for k in range(len(frame2)):
            if frame2.at[k,'ballot']!='':
                if frame2.at[k,'ballot'][0] in vote_counts.keys():
                    vote_counts[frame2.at[k,'ballot'][0]]+=frame2.iloc[k]['Count']
                else:
                    vote_counts[frame2.at[k,'ballot'][0]]=frame2.iloc[k]['Count']
    
    max_count=max(vote_counts.values())
    while len(winners)<S:
        
        max_count=max(vote_counts.values())
        #somebody is elected and we have to transfer their votes
        if max_count>=quota:
            #There might be multiple people elected this round; save them as a sorted dictionary
            votes_for_winners={k:vote_counts[k] for k in vote_counts.keys() if vote_counts[k]>=quota }
            votes_for_winners=dict(sorted(votes_for_winners.items(),key=lambda x: x[1], reverse=True))
            
            #If we try to elect too many people, need to drop someone who surpassed quota
            if len(winners)+len(votes_for_winners)>S:
                
                for k in range(len(winners)+len(votes_for_winners)-S):
                    winners.append(list(votes_for_winners.keys())[k])
            
            else:
                winners=winners+list(votes_for_winners.keys())
                for cand in winners:
                    if cand in hopefuls:
                        hopefuls.remove(cand)
                
                while len(votes_for_winners)>0:
                    
                    cand=list(votes_for_winners.keys())[0]
    
                    if cand not in winners:
                        winners.append(cand)
                        hopefuls.remove(cand)
                    if len(winners)==S:
                        return winners
                    
                    weight=truncate((vote_counts[cand]-quota)/vote_counts[cand],5)
                    
                    for k in range(len(frame2)):
                        if frame2.at[k,'ballot']!='':
                            if frame2.at[k,'ballot'][0]==cand:
                                
                                frame2.at[k,'Count']=frame2.at[k,'Count']*weight
                                for x in winners:
                                    if x in frame2.at[k,'ballot']:
                                        frame2.at[k,'ballot']=frame2.at[k,'ballot'].replace(x,'')
                            else:
                                if cand in frame2.at[k,'ballot']:
                                     frame2.at[k,'ballot']=frame2.at[k,'ballot'].replace(cand,'')
                    votes_for_winners.pop(cand)
                    vote_counts={}
                    
                    for k in range(len(frame2)):
                        if frame2.at[k,'ballot']!='':
                            if frame2.at[k,'ballot'][0] in vote_counts.keys():
                                vote_counts[frame2.at[k,'ballot'][0]]+=frame2.iloc[k]['Count']
                            else:
                                vote_counts[frame2.at[k,'ballot'][0]]=frame2.iloc[k]['Count']

                    votes_for_winners={k:vote_counts[k] for k in vote_counts.keys() if vote_counts[k]>=quota }
                    votes_for_winners=dict(sorted(votes_for_winners.items(),key=lambda x: x[1], reverse=True))
                    for cand in votes_for_winners.keys():
                        if cand not in winners:
                            winners.append(cand)
                            hopefuls.remove(cand)
                    if len(winners)==S:
                        return winners
                    frame2=pd.DataFrame(frame2.groupby(['ballot'],as_index=False)['Count'].sum())
        #nobody is elected by surpassing quota, but the number
        #of candidates left equals S
        elif len(hopefuls)+len(winners)==S:
            return winners+hopefuls
        
        #remove weakest cand and transfer their votes with weight one
        else:
            min_count=min(i for i in vote_counts.values() if i>0)
            count=0
            for votes in vote_counts:
                if votes==min_count:
                    count+=1
            if count>1:
                print("tie in candidate to remove")
                return

            eliminated_cand = list(vote_counts.keys())[list(vote_counts.values()).index(min_count)] 
            
            eliminatedCand.append(eliminated_cand)
            hopefuls.remove(eliminated_cand)
            
            for k in range(len(frame2)):
                if eliminated_cand in frame2.iloc[k]['ballot']:
                    frame2.at[k,'ballot']=frame2.at[k,'ballot'].replace(eliminated_cand,'')
            for k in range(len(frame2)):
                if frame2.at[k,'ballot']=='':
                    frame2.drop(k)
            vote_counts={}
           
            for k in range(len(frame2)):
                if frame2.at[k,'ballot']!='':
                    if frame2.at[k,'ballot'][0] in vote_counts.keys():
                        vote_counts[frame2.at[k,'ballot'][0]]+=frame2.iloc[k]['Count']
                    else:
                        vote_counts[frame2.at[k,'ballot'][0]]=frame2.iloc[k]['Count']
                        
            max_count=max(vote_counts.values())
            if len(hopefuls)+len(winners)==S:
                return winners+hopefuls
            frame2=pd.DataFrame(frame2.groupby(['ballot'],as_index=False)['Count'].sum())
    return winners


#Cell 2: Monotonicity anomaly function defined 
#Code written by Dave McCune and Adam Graham-Squire

#Note: this code only looks for anomalies cause by changes in the dropout order
import copy

def modifyUp(winner, ballot):
    """inputs a candidate and a ballot, and moves candidate to top of ballot if candidate is in ballot. 
    Otherwise adds candidate to top of ballot"""
    if winner in ballot:
        modified = winner + ballot.replace(winner, "")
    else:
        modified = winner + ballot
    return modified

def monoAnomSearch(frame, n, S): 
    """inputs: dataframe of election, n= number of candidates, S= number of seats
    runs election to find winners/losers/prefData before candidate eliminated, tempWinners,
    then identifies and makes vote swaps to find 
    upward monotonicity anomalies.  Returns if an anomaly exists, and how anomaly happens""" 
    quota=math.floor(sum(frame['Count'])/(S+1))+1 #calculate quota   
    winners, losers, elimFrames, winners_dict=STV3(frame,n,S) #get election data from STV3
    print("Original winners are ")
    print(winners)
   
    for i in range(len(losers)): #function looks at real data before ith loser drops, 
        # then searches for all possible anomalies at a given level<=n, right before each "loser" is 
        # eliminated.  outputs if anomaly occurs, and if so, how...could also output other information
        print("")
        print("Results at the " +str(n-i)+"-candidate level:")
        
        tempFrame = elimFrames[i].copy(deep=True) #actual data before ith cand is removed 
        tempWinners = copy.deepcopy(winners_dict[i])
        remainingWinners = copy.deepcopy(winners) #put in all winners
        for y in range(len(tempWinners)):
            remainingWinners.remove(tempWinners[y]) #remove people who already got seats
        # remainingWinners are the future winners who are still in the election
        loser = losers[i]
        vote_counts={}
        for k in range(len(tempFrame)):
            if tempFrame.at[k,'ballot']!='':
                if tempFrame.at[k,'ballot'][0] in vote_counts.keys():
                    vote_counts[tempFrame.at[k,'ballot'][0]]+=tempFrame.iloc[k]['Count']
                else:
                    vote_counts[tempFrame.at[k,'ballot'][0]]=tempFrame.iloc[k]['Count']
        print("")
        print("Out of " + str(n) + " candidates, results at the " +str(len(vote_counts))+"-candidate level for Elimination Order anomaly:")
        
        print(vote_counts)
        quota_gap = {} #track how many votes candidates need to get quota
        for x in range(len(remainingWinners)):
            quota_gap[remainingWinners[x]]=quota-vote_counts[remainingWinners[x]]   
        loser_gap ={} #gap in votes between a candidate and the losing candidate
        for x in range(len(vote_counts)):
            loser_gap[list(vote_counts.keys())[x]]=vote_counts[list(vote_counts.keys())[x]]-vote_counts[loser]                                                                           
                                                                                    
        for j in range(len(remainingWinners)):
            # search for anomalies for each winner W_j=remainingWinners[j]: 
            if quota_gap[remainingWinners[j]] < 0:
                print("No anomaly for " + remainingWinners[j] + ".  Meets quota at " + str(n-i) + "-candidate level." +
                      " NOTE: THIS SHOULD NOT EVER HAPPEN.  IF YOU SEE THIS THEN THERE IS A MISTAKE")
            else:
                checkables = list(vote_counts.keys()) #list of all candidates
                checkables.remove(remainingWinners[j]) #remove winner from checkables
                checkables.remove(loser)#remove loser/next eliminated candidate from checkables 
                
                #we now try to modify C_k...W_j ballots to change dropout order, see if it changes overall result 
                for k in range(len(checkables)): #choose the kth checkable = C_k
                    gap = loser_gap[checkables[k]]
                    if gap > quota_gap[remainingWinners[j]]:
                        print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                        " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                              " meets quota before change in dropout order." )   
                    else: #check for 1-rankings first, most likely to cause anomaly
                        tempFrame1 = tempFrame.copy(deep=True)
                        modifiableVotes1 = 0 #modifiableVotes_kj1 = sum of all ballots that start with C_k W_j
                        for z in range(len(tempFrame1)):
                            currentBallot = tempFrame1.at[z,'ballot']
                            try:
                                currentBallot[1]
                            except: 
                                continue
                            else:
                                if currentBallot[0]==checkables[k] and currentBallot[1]==remainingWinners[j]:
                                    modifiableVotes1 += tempFrame1.at[z,'Count']
                        if modifiableVotes1 > gap: #if so, can change dropout order just by modifying these ballots
                            check = copy.deepcopy(gap)
                            
                            for z in range(len(tempFrame1)):
                                if check>=0:
                                    currentBallot = tempFrame1.at[z,'ballot']
                                    try:
                                        currentBallot[1]
                                    except: 
                                        continue
                                    else:
                                        if currentBallot[0]==checkables[k] and currentBallot[1]==remainingWinners[j]:
                                            if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                print("Ballot modified is " + tempFrame1.at[z,'ballot'] + " at line "+ str(z))
                                                tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                print("Ballot modified to " + tempFrame1.at[z,'ballot'])
                                                check = check - tempFrame1.at[z,'Count']
                                                print("check is now " +str(check))
                                            else: #modify only check+1 such ballots
                                                print("Ballot modified is " + tempFrame1.at[z,'ballot'] + " at line "+ str(z))
                                                tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)
                                                #now add new line to frame with modified ballot
                                                tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                check = -1
                                        else:
                                            pass
                            # Run STV election on modifed election.  Check to see if W_j is in new winners list
                            # if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate level.
                            # votes modified to 1 ranking"
                            win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota)
                            if remainingWinners[j] in win1:
                                print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                  " still wins after change in dropout order." )
                            else:
                                modifiedNum = gap - check
                                print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                " at the "+ str(n-i) + "-candidate level!!!! Modifying " + str(modifiedNum) +" "+checkables[k]+ remainingWinners[j]+"_"  
                                  " to " +  remainingWinners[j]+checkables[k]+ "_ makes " + remainingWinners[j]+ " lose their seat.")
                                print("Original winners were " + str(remainingWinners))
                                print("New winners are " + str(win1))
                                print('Modified election is')
                                display(tempFrame1)
                        
                        #if C_k W_j ballots were not enough to make up gap, modify all of them and try next mod
                        else:
                                # modify all modifiableVotes C_k W_j votes in reduced_df to become W_j C_k 
                            for z in range(len(tempFrame1)):
                                currentBallot = tempFrame1.at[z,'ballot']
                                try:
                                    currentBallot[1]
                                except: 
                                    continue
                                else:
                                    if currentBallot[0]==checkables[k] and currentBallot[1]==remainingWinners[j]:
                                        tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                        gap = gap - tempFrame1.at[z,'Count']
                            
                            #CHECK THE 2-RANKINGS 
                            # modifiableVotes_kj2 = sum of all ballots that start with C_k ___ W_j  ##that is, 
                                # ballots with C_k in first, W_j in third, anything else in second
                            modifiableVotes2 = 0 #modifiableVotes2 = sum of all ballots that start with C_k ___ W_j
                            for z in range(len(tempFrame1)):
                                currentBallot = tempFrame1.at[z,'ballot']
                                try:
                                    currentBallot[2]
                                except: 
                                    continue
                                else:
                                    if currentBallot[0]==checkables[k] and currentBallot[2]==remainingWinners[j]:
                                        modifiableVotes2 += tempFrame1.at[z,'Count']  

                            if modifiableVotes2 > gap:  # modify gap of the C_k __ W_j votes in modified_df_kj1 to become 
                                                        # W_j C_k ___ votes.
                                
                                check = copy.deepcopy(gap)
                                for z in range(len(tempFrame1)): #tempFrame in place of reduceFrame(frame,losers)[i]
                                    if check>=0:
                                        currentBallot = tempFrame1.at[z,'ballot']
                                        try:
                                            currentBallot[2]
                                        except: 
                                            continue
                                        else:
                                            if currentBallot[0]==checkables[k] and currentBallot[2]==remainingWinners[j]:
                                                if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                    tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                    check = check - tempFrame1.at[z,'Count']

                                                else: #modify only check+1 such ballots
                                                    #take check+1 ballots from current ballot
                                                    tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                    #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                    tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                    check = -1
                                            else:
                                                pass
                                        
                                # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                # level. votes modified to 2 rankings"
                                win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota) #n-i?
                                if remainingWinners[j] in win1:
                                    
                                    print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                    " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                      " still wins after change in dropout order." )
                                else:
                                    modifiedNum = gap - check
                                    print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                    " at the "+ str(n-i) + "-candidate level!!!! ")
                                    print("Modifying all 1-rankings and " + str(modifiedNum) + 
                                    " 2-rankings makes " + remainingWinners[j]+ " lose their seat.") 
                                    print("Original winners were " + str(remainingWinners))
                                    print("New winners are " + str(win1))
                                    print('Modified election is')
                                    display(tempFrame1)
                                
                            else: 
                                # modify all modifiableVotes C ___  W votes in reduced_df to become W_j C_k ___
                                for z in range(len(tempFrame1)):
                                    currentBallot = tempFrame1.at[z,'ballot']
                                    try:
                                        currentBallot[2]
                                    except: 
                                        continue
                                    else:
                                        if currentBallot[0]==checkables[k] and currentBallot[2]==remainingWinners[j]:
                                            tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                            gap = gap - tempFrame1.at[z,'Count']

                                #CHECK THE 3-RANKINGS
                                # modifiableVotes3 = sum of all ballots that start with C_k ___ __ W_j  ##that is, 
                                    # ballots with C_k in first, W_j in fourth, anything else in between
                                modifiableVotes3 = 0 
                                for z in range(len(tempFrame1)):
                                    currentBallot = tempFrame1.at[z,'ballot']
                                    try:
                                        currentBallot[3]
                                    except: 
                                        continue
                                    else:
                                        if currentBallot[0]==checkables[k] and currentBallot[3]==remainingWinners[j]:
                                            modifiableVotes3 += tempFrame1.at[z,'Count']  

                                if modifiableVotes3 > gap:  # modify gap of the C_k __ W_j votes in modified_df_kj1 to become 
                                                            # W_j C_k ___ votes.

                                    check = copy.deepcopy(gap)
                                    for z in range(len(tempFrame1)): 
                                        if check>=0:
                                            currentBallot = tempFrame1.at[z,'ballot']
                                            try:
                                                currentBallot[3]
                                            except: 
                                                continue
                                            else:
                                                if currentBallot[0]==checkables[k] and currentBallot[3]==remainingWinners[j]:
                                                    if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                        tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                        check = check - tempFrame1.at[z,'Count']

                                                    else: #modify only check+1 such ballots
                                                        #take check+1 ballots from current ballot
                                                        tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                        #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                        tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                        check = -1
                                                else:
                                                    pass

                                    # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                    # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                    # level. votes modified to 2 rankings"
                                    win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota)#n-i?
                                    if remainingWinners[j] in win1:

                                        print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                        " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                          " still wins after change in dropout order." )
                                    else:
                                        modifiedNum = gap - check
                                        print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                        " at the "+ str(n-i) + "-candidate level!!!! ")
                                        print("Modifying all 1- and 2- rankings and " + str(modifiedNum) + 
                                        " 3-rankings makes " + remainingWinners[j]+ " lose their seat.") 
                                        print("Original winners were " + str(remainingWinners))
                                        print("New winners are " + str(win1))
                                        print('Modified election is')
                                        display(tempFrame1)

                                else: 
                                    # modify all modifiableVotes_kj1 C ___ ___ W votes in reduced_df to become W_j C_k ___
                                    for z in range(len(tempFrame1)):
                                        currentBallot = tempFrame1.at[z,'ballot']
                                        try:
                                            currentBallot[3]
                                        except: 
                                            continue
                                        else:
                                            if currentBallot[0]==checkables[k] and currentBallot[3]==remainingWinners[j]:
                                                tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                gap = gap - tempFrame1.at[z,'Count']

                                    #CHECK THE 4-RANKINGS
                                    # modifiableVotes4 = sum of all ballots that start with C_k ___ __ ___ W_j  ##that is, 
                                        # ballots with C_k in first, W_j in fourth, anything else in between
                                    modifiableVotes4 = 0 # = sum of all ballots that start with 4-ranking
                                    for z in range(len(tempFrame1)):
                                        currentBallot = tempFrame1.at[z,'ballot']
                                        try:
                                            currentBallot[4]
                                        except: 
                                            continue
                                        else:
                                            if currentBallot[0]==checkables[k] and currentBallot[4]==remainingWinners[j]:
                                                modifiableVotes4 += tempFrame1.at[z,'Count']  

                                    if modifiableVotes4 > gap:  # modify gap of the C_k __ W_j votes in modified_df_kj1 to become 
                                                                # W_j C_k ___ votes.

                                        check = copy.deepcopy(gap)
                                        for z in range(len(tempFrame1)): 
                                            if check>=0:
                                                currentBallot = tempFrame1.at[z,'ballot']
                                                try:
                                                    currentBallot[4]
                                                except: 
                                                    continue
                                                else:
                                                    if currentBallot[0]==checkables[k] and currentBallot[4]==remainingWinners[j]:
                                                        if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                            tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                            check = check - tempFrame1.at[z,'Count']

                                                        else: #modify only check+1 such ballots
                                                            #take check+1 ballots from current ballot
                                                            tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                            #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                            tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                            check = -1
                                                    else:
                                                        pass

                                        # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                        # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                        # level. votes modified to 2 rankings"
                                        win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota)#n-i?
                                        if remainingWinners[j] in win1:

                                            print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                            " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                              " still wins after change in dropout order." )
                                        else:
                                            modifiedNum = gap - check
                                            print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                            " at the "+ str(n-i) + "-candidate level!!!! ")
                                            print("Modifying all 1-, 2-, and 3-rankings and " + str(modifiedNum) + 
                                            " 4-rankings makes " + remainingWinners[j]+ " lose their seat.") 
                                            print("Original winners were " + str(remainingWinners))
                                            print("New winners are " + str(win1))
                                            print('Modified election is')
                                            display(tempFrame1)


                                    else:
                                        # modify all modifiableVotes_kj1 C ___ ___ ___W votes in reduced_df to become W_j C_k ___
                                        for z in range(len(tempFrame1)):
                                            currentBallot = tempFrame1.at[z,'ballot']
                                            try:
                                                currentBallot[4]
                                            except: 
                                                continue
                                            else:
                                                if currentBallot[0]==checkables[k] and currentBallot[4]==remainingWinners[j]:
                                                    tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                    gap = gap - tempFrame1.at[z,'Count']
                                        
                                        #CHECK THE 5-RANKINGS
                                        # modifiableVotes5 = sum of all ballots  
                                            # with C_k in first, W_j in sixth, anything else in between
                                        modifiableVotes5 = 0 # = sum of all 5-ranking ballots that start with C_k 
                                        for z in range(len(tempFrame1)):
                                            currentBallot = tempFrame1.at[z,'ballot']
                                            try:
                                                currentBallot[5]
                                            except: 
                                                continue
                                            else:
                                                if currentBallot[0]==checkables[k] and currentBallot[5]==remainingWinners[j]:
                                                    modifiableVotes5 += tempFrame1.at[z,'Count']  

                                        if modifiableVotes5 > gap:  # modify gap of the C_k __ W_j votes in modified_df_kj1 to become 
                                                                    # W_j C_k ___ votes.

                                            check = copy.deepcopy(gap)
                                            for z in range(len(tempFrame1)): #tempFrame in place of reduceFrame(frame,losers)[i]
                                                if check>=0:
                                                    currentBallot = tempFrame1.at[z,'ballot']
                                                    try:
                                                        currentBallot[5]
                                                    except: 
                                                        continue
                                                    else:
                                                        if currentBallot[0]==checkables[k] and currentBallot[5]==remainingWinners[j]:
                                                            if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                                tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                                check = check - tempFrame1.at[z,'Count']

                                                            else: #modify only check+1 such ballots
                                                                #take check+1 ballots from current ballot
                                                                tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                                #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                                tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                                check = -1
                                                        else:
                                                            pass

                                            # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                            # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                            # level. votes modified to 2 rankings"
                                            win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota) #n-i?
                                            if remainingWinners[j] in win1:

                                                print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                                  " still wins after change in dropout order." )
                                            else:
                                                modifiedNum = gap - check
                                                print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                " at the "+ str(n-i) + "-candidate level!!!! ")
                                                print("Modifying all 1-, 2-, 3- and 4-rankings and " + str(modifiedNum) + 
                                                " 5-rankings makes " + remainingWinners[j]+ " lose their seat.") 
                                                print("Original winners were " + str(remainingWinners))
                                                print("New winners are " + str(win1))
                                                print('Modified election is')
                                                display(tempFrame1)


                                        else:
                                            # modify all modifiableVotes C ... W votes in reduced_df to become W_j C_k ___
                                            for z in range(len(tempFrame1)):
                                                currentBallot = tempFrame1.at[z,'ballot']
                                                try:
                                                    currentBallot[5]
                                                except: 
                                                    continue
                                                else:
                                                    if currentBallot[0]==checkables[k] and currentBallot[5]==remainingWinners[j]:
                                                        tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                        gap = gap - tempFrame1.at[z,'Count']
                                            
                                            #We chose to modify most/all of ranked votes before doing bullet votes, as we think
                                            # that is most likely to case anomalies
                                            #CHECK THE BULLET VOTES, length 1
                                              ##that is, 
                                                # ballots with just C_k in first
                                            modifiableVotesBullet1 = 0 # = sum of all bullet votes w/ length 1
                                            for z in range(len(tempFrame1)):
                                                currentBallot = tempFrame1.at[z,'ballot']
                                                if len(currentBallot) == 1:
                                                    if currentBallot[0]==checkables[k]:
                                                            modifiableVotesBullet1 += tempFrame1.at[z,'Count']  

                                            if modifiableVotesBullet1 > gap:  # modify gap of the C_k  votes in modified_df_kj1 to become 
                                                                        # W_j C_k votes.

                                                check = copy.deepcopy(gap)
                                                for z in range(len(tempFrame1)): 
                                                    if check>=0:
                                                        currentBallot = tempFrame1.at[z,'ballot']
                                                        if len(currentBallot) == 1:
                                                            if currentBallot[0]==checkables[k]:
                                                                if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                                    tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                                    check = check - tempFrame1.at[z,'Count']

                                                                else: #modify only check+1 such ballots
                                                                    #take check+1 ballots from current ballot
                                                                    tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                                    #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                                    tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                                    check = -1

                                                # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                                # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                                # level. votes modified to 2 rankings"
                                                win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota)
                                                if remainingWinners[j] in win1:

                                                    print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                    " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                                      " still wins after change in dropout order." )
                                                else:
                                                    modifiedNum = gap - check
                                                    print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                    " at the "+ str(n-i) + "-candidate level!!!! ")
                                                    print("Modifying all 1-, 2-, 3- and 4-rankings and " + str(modifiedNum) + 
                                                    " 1-bullet votes makes " + remainingWinners[j]+ " lose their seat.") 
                                                    print("Original winners were " + str(remainingWinners))
                                                    print("New winners are " + str(win1))
                                                    print('Modified election is')
                                                    display(tempFrame1)


                                            else:
                                                # modify all modifiableVotes C_k  votes in reduced_df to become W_j C_k 
                                                for z in range(len(tempFrame1)):
                                                    currentBallot = tempFrame1.at[z,'ballot']
                                                    if len(currentBallot) == 1:
                                                        if currentBallot[0]==checkables[k]:
                                                            tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                            gap = gap - tempFrame1.at[z,'Count']

                                                #CHECK THE BULLET VOTES, length 2
                                                # modifiableVotesBullet2 = sum of all ballots that are just C_k C_i  
                                                modifiableVotesBullet2 = 0 # = sum of all bullet votes w/ length 2
                                                for z in range(len(tempFrame1)):
                                                    currentBallot = tempFrame1.at[z,'ballot']
                                                    if len(currentBallot) == 2:
                                                        if currentBallot[0]==checkables[k] and currentBallot[1]!=remainingWinners[j]: 
                                                                modifiableVotesBullet2 += tempFrame1.at[z,'Count']  

                                                if modifiableVotesBullet2 > gap:  # modify gap of the C_k C_i votes in modified to become 
                                                                            # W_j C_k C_i votes.

                                                    check = copy.deepcopy(gap)
                                                    for z in range(len(tempFrame1)): 
                                                        if check>=0:
                                                            currentBallot = tempFrame1.at[z,'ballot']
                                                            if len(currentBallot) == 2:
                                                                if currentBallot[0]==checkables[k] and currentBallot[1]!=remainingWinners[j]: 
                                                                    if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                                        tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                                        check = check - tempFrame1.at[z,'Count']

                                                                    else: #modify only check+1 such ballots
                                                                        #take check+1 ballots from current ballot
                                                                        tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                                        #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                                        tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                                        check = -1

                                                    # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                                    # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                                    # level. votes modified to 2 rankings"
                                                    win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota)#n-i?
                                                    if remainingWinners[j] in win1:

                                                        print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                        " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                                          " still wins after change in dropout order." )
                                                    else:
                                                        modifiedNum = gap - check
                                                        print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                        " at the "+ str(n-i) + "-candidate level!!!! ")
                                                        print("Modifying all 1-, 2-, 3- and 4-rankings and " + str(modifiedNum) + 
                                                        " 1-bullet votes makes " + remainingWinners[j]+ " lose their seat.") 
                                                        print("Original winners were " + str(remainingWinners))
                                                        print("New winners are " + str(win1))
                                                        print('Modified election is')
                                                        display(tempFrame1)


                                                else:
                                                    # modify all modifiableVotes C_k  votes in reduced_df to become W_j C_k 
                                                    for z in range(len(tempFrame1)):
                                                        currentBallot = tempFrame1.at[z,'ballot']
                                                        if len(currentBallot) == 2:
                                                            if currentBallot[0]==checkables[k] and currentBallot[1]!=remainingWinners[j]: #Note: should not need and
                                                                tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                                gap = gap - tempFrame1.at[z,'Count']

                                                    #CHECK THE BULLET VOTES, length 3
                                                    # modifiableVotesBullet3 = sum of all ballots that are just C_k ___ C_i  
                                                    modifiableVotesBullet3 = 0 # = sum of all bullet votes w/ length 3
                                                    for z in range(len(tempFrame1)):
                                                        currentBallot = tempFrame1.at[z,'ballot']
                                                        if len(currentBallot) == 3:
                                                            if currentBallot[0]==checkables[k] and remainingWinners[j] not in currentBallot: 
                                                                    modifiableVotesBullet3 += tempFrame1.at[z,'Count']  

                                                    if modifiableVotesBullet3 > gap:  # modify gap of the C_k C_i votes in modified to become 
                                                                                # W_j C_k C_i votes.

                                                        check = copy.deepcopy(gap)
                                                        for z in range(len(tempFrame1)): 
                                                            if check>=0:
                                                                currentBallot = tempFrame1.at[z,'ballot']
                                                                if len(currentBallot) == 3:
                                                                    if currentBallot[0]==checkables[k] and remainingWinners[j] not in currentBallot: #Note: should not need and
                                                                        if check - tempFrame1.at[z,'Count']>=0: #modify all such ballots
                                                                            tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                                            check = check - tempFrame1.at[z,'Count']

                                                                        else: #modify only check+1 such ballots
                                                                            #take check+1 ballots from current ballot
                                                                            tempFrame1.at[z,'Count'] = tempFrame1.at[z,'Count']-(check+1)  
                                                                            #make new ballot with winner moved up, add line to election frame with check+1 as count
                                                                            tempFrame1.loc[len(tempFrame1)] = [modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot']), check+1]
                                                                            check = -1

                                                        # Run STV election on modifed_df_kj2.  Check to see if W_j is in new winners 
                                                        # list. if yes, report "no anomaly for W_j with C_k under L at (n-i)-candidate 
                                                        # level. votes modified to..."
                                                        win1 = STV_temp(tempFrame1, len(vote_counts), S, tempWinners, quota) #n-i?
                                                        if remainingWinners[j] in win1:

                                                            print("No anomaly for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                            " at the "+ str(n-i) + "-candidate level. " + remainingWinners[j] + 
                                                              " still wins after change in dropout order." )
                                                        else:
                                                            modifiedNum = gap - check
                                                            print("MONOTONICITY ANOMALY for " + remainingWinners[j] + " with " + checkables[k] + " under " + loser + 
                                                            " at the "+ str(n-i) + "-candidate level!!!! ")
                                                            print("Modifying all 1-, 2-, 3-, 4- and 5-rankings and " + str(modifiedNum) + 
                                                            " 3-bullet votes makes " + remainingWinners[j]+ " lose their seat.") 
                                                            print("Original winners were " + str(remainingWinners))
                                                            print("New winners are " + str(win1))
                                                            print('Modified election is')
                                                            display(tempFrame1)


                                                    else:
                                                        # modify all modifiableVotes C_k  votes in reduced_df to become W_j C_k 
                                                        for z in range(len(tempFrame1)):
                                                            currentBallot = tempFrame1.at[z,'ballot']
                                                            if len(currentBallot) == 3:
                                                                if currentBallot[0]==checkables[k] and remainingWinners[j] not in currentBallot: 
                                                                    tempFrame1.at[z,'ballot'] = modifyUp(remainingWinners[j],tempFrame1.at[z,'ballot'])
                                                                    gap = gap - tempFrame1.at[z,'Count']


                                                    print(remainingWinners[j]+" cannot overcome gap with "+ checkables[k] + 
                                                          " when modified up to 5 rankings and 3 bullet votes under " + 
                                                          loser + ". REACHED END OF CODE.")


#Cell 3: import data and run mono Anomaly code
#Code written by Dave McCune

File=open('DownwardAnomalyElections/2021_Portland_PrefSched_Top3gone.txt','r') 
#open election data file
lines=File.readlines()

first_space=lines[0].find(' ')

num_cands=int(lines[0][0:first_space])#strip candidate number and seats from first line
num_seats=int(lines[0][first_space+1])

column_names=['ballot','Count']
data=pd.DataFrame(columns = column_names)
for k in range(1,len(lines)): #change candidate numbers to letters
    if lines[k][0]=='0': #stop when line is just a 0
        break
    first_space=lines[k].find(' ')
    count=int(lines[k][0:first_space])
    end=lines[k].find(' 0')
    ballot=lines[k][first_space+1:end+1]
    if '10 ' in ballot:
        ballot=ballot.replace('10 ','J ')
    if '11 ' in ballot:
        ballot=ballot.replace('11 ','K ')
    if '12 ' in ballot:
        ballot=ballot.replace('12 ','L ')
    if '13 ' in ballot:
        ballot=ballot.replace('13 ', 'M ')
    if '14 ' in ballot:
        ballot=ballot.replace('14 ', 'N ')
    if '1 ' in ballot:
        ballot=ballot.replace('1 ','A ')
    if '2 ' in ballot:
        ballot=ballot.replace('2 ','B ')
    if '3 ' in ballot:
        ballot=ballot.replace('3 ','C ')
    if '4 ' in ballot:
        ballot=ballot.replace('4 ','D ')
    if '5 ' in ballot:
        ballot=ballot.replace('5 ','E ')
    if '6 ' in ballot:
        ballot=ballot.replace('6 ','F ')
    if '7 ' in ballot:
        ballot=ballot.replace('7 ','G ')
    if '8 ' in ballot:
        ballot=ballot.replace('8 ','H ')
    if '9 ' in ballot:
        ballot=ballot.replace('9 ','I ')
    
    while ' ' in ballot:
        ballot=ballot.replace(' ','')
    
    row={'Count':[float(count)], 'ballot':[ballot]}
    df2=pd.DataFrame(row)
    data=pd.concat([data, df2], ignore_index=True)
    
data_copy=data.copy(deep=True) 
monoAnomSearch(data_copy,num_cands,num_seats) #run the Monotonicity anomaly search
